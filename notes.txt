Fiji master branch can override versions of things, right?
- ImageJ2 master branch can do this, too.
- So... why not just have people update the

1. Split Java-8 in half.
   - One "legacy base" XML file for ImageJ2.
   - Second one for Fiji-layer components.

2. Then, list of Vs for net.imagej:imagej, to layer on top of the ImageJ2 base.

3. Same for Fiji: list of Vs for sc.fiji:fiji.

4. Better(?): not even a list of Vs. Just a pointer to the current one, which is manually bumped when we want to update Fiji?

5. Disable uploads to Java-8 site.
   - When people want to push updates, they push it to fiji master, or imagej2 master.
   - fiji/fiji (or fiji/fiji-builds?) CI pushes latest state to Fiji/8-dev/ unstable update site.
   - The dev site(s) would need to deal with fiji SNAPSHOT though... and the whole git history, not just tip of master.

   - What do we need for reproducibility?
     - Commit hash of imagej/imagej
     - Commit hash of fiji/fiji

   - What do we need for updates to work?
     - List of all versions historically

   - What do we need for downgrades to work?
     - Depends, but... let's suppose we want to support downgrading to a stated V of the update site's GA.
     - Oof, one way to do it would be a separate db.xml.gz file per downgradeable version.
     - These files would be immutable state declarations.
     - With this, we wouldn't need the obsoleted timestamps anymore.
     - We could support anything, not only Maven GAV... just need to grab the db.xml.gz files out of the Fiji tarballs that already exist, especially the Life-Line versions.
     - Can be done separately later, not needed immediately.

   - What do we need for major JDK updates to work?
     - The updater needs to learn to check the right track for its JDK version.
     - Use the newest track <= the current version. So e.g. Java 14 would use sites.imagej.net/ImageJ2/11/ because 11 <= 14 < 17.
     - Need to code-generate these tracks?
     - Add-on update sites that want to support this model need to publish artifacts to Maven repositories with proper POMs.

   - What about tracking git branches? Challenges:
     - No perma-binary for those builds.
     - But... we only need to support upgrading *to latest*, while retaining hashes of older states.
     - Notably, do not retain older snapshot binaries.
     - We must save all hashes of dev builds forever, though... where to save them?

So what are we doing?

1. Maven-driven generator makes *one db.xml.gz per release version*.
   - Each db.xml.gz knows its minimum needed version of Java.
   - Each db.xml.gz is named and date-stamped matching the release version of the linked GAV.
   - These db.xml.gz files are distributed accordingly to the correct Java version tracks.
     - E.g. suppose fiji 2.10.0 requires Java, but 2.20.0 requires Java 11.
     - Then db-2.10.0.xml.gz exists on /8/ and /11/ tracks, but db-2.20.0.xml.gz exists only on /11/ track.

2. Each db.xml.gz is built on top of all previous ones, in order.
   - Not quite. Each db.xml.gz has *everything*, but the *current* version is the desired one for that db.xml.gz.
   - Having more known hashes avoids "Locally modified" status.
   - But regenerating db.xml.gz files for older release versions is unfortunate -- do we need to do it?

3. Updater can learn to tell if a Java track is dead-ended by a new telltale in the db.xml.gz.
   - Is it sufficient to have a generic warning like "This may not be the actual latest version"?

Is it worth doing this?
- https://update.imagej.net/8/ -> https://sites.imagej.net/ImageJ2/8/
- https://update.fiji.sc/8/ -> https://sites.imagej.net/Fiji/8/

Work I need to do:

A. Split existing Java-8/db.xml.gz into two pieces.
   - Might enough to leave EVERYTHING, but mark all Fiji-specific things as obsolete in the ImageJ2 base one?
   - But I'd like to fully remove the things that were only ever part of Fiji and not core ImageJ2.

B. Teach the Updater new tricks.
   - Java version tracks: e.g. /8/, /11/
   - Teach it to "downgrade" by upgrading to a specific db-<label>.tar.gz file.
     - The db.xml.gz has a new <versions> section for downgrades, with nothing else but list of <label> with datestamps and required Java versions.
   - Consider teaching it to support checksums from Maven repos.

C. Generate db.xml.gz files from Maven GAV.

What if the Updater was standalone with no dependencies?
- Avoids "updating the Updater" problem.
- Could be the most foundational update site: SciJava <update.scijava.org>.
- Stuck on Java 6 forever, but who cares, keep minimal.
- Could *REMOVE* imagej-updater dependency from net.imagej:imagej!
- scijava-updater has Swing UI in it as well, it's messy, deal with it.
- What about Help > Update...? Probably needs to be part of the scijava-updater.jar, no? But how...
- New site stack would be: SciJava < ImageJ2 < ImageJ-Legacy < Fiji < Fiji-Legacy
- But I'm not sure... what about third-party update sites where people manually upload? I guess we want to keep supporting this model. :-/
  - I do think we need a way to fix bugs in the Updater independently of everything else though.
  - The scijava-updater db.xml.gz generator can also be used to fix things that confuse older versions of the Updater.
  - If the foundational SciJava update site always lists scijava-updater.jar as its sole thing...
  - ...it might work. But we need to check if the current ImageJ Updater is OK with obsoleting itself.
